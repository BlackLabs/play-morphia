h1. Mongo module

The mongo module adds "MongoDB":http://www.mongodb.org support for the Play! framework.

h2. <a>Enable the Mongo module for the application</a>

In the **/conf/application.conf** file, enable the Mongo module by adding this line:


bc.. # The mongo module
module.mongo=${play.path}/modules/mongo

# mongodb connection details
mongo.host=localhost
mongo.port=27017
mongo.database=play

mongo.username=test
mongo.password=test123
h2. <a>Defining your models</a>

Creating models to be stored in your Mongo database is very similar to the method of creating
models in the Play! framework for storage in an SQL database. Provide them with an annotation 
and have them inherit from a base class, as follows:

bc.. @MongoEntity("collectionName")
public class Car extends MongoModel {

	public String name;
	public String colour;
	public int topSpeed;
	
}
p. If collectionName is not supplied as a value to the annotation, the collection name will be the 
same as the class name.


h2. <a>Using your models</a>

After defining your models, you can use them in the same way as you would a standard SQL based
model in Play! framework. The examples below describe how you might use your Mongo based models in a controller.

h3. Saving

Saving is simple.

bc.. Car myCar = new Car("Toyota", "white", 150);
myCar.save();
h3. Finding

There are a number of ways to find your models.

bc.. //get all cars
List<Car> allCars = Car.find().fetch();

//get any five cars
List<Car> fiveCars = Car.find().fetch(5);

//get any two cars with offset of 3
List<Car> offsetCars = Car.find().from(3).fetch(2);

//get the third page of 20 cars
List<Car> pageOfCars = Car.find().fetch(3,20);

//get only one car
Car c = Car.find().first();
h3. Query Strings

You can pass query strings when using the find method like so:

bc.. List<Car> toyotas = Car.find("byName", "Toyota").fetch();

List<Car> whiteToyotas = Car.find("byNameAndColour", "Toyota", "white").fetch();
p. Currently the Mongo module only supports the 'And' query operator.

h3. Ordering

Ordering your results is very simple, allowing the use of a query very similar to the find.

bc.. List<Car> ascendingNameCars = Car.find().order("byName").fetch();

// to perform a descending order, prefix the field with '-'
List<Car> descendingNameCars = Car.find().order("by-Name").fetch();

h3. Counting your models

Counting your models is again, simple.

bc.. long count = Car.count()

// alternatively, pass a query string
long toyotaCount = Car.count("byName", "Toyota");
h3. Deleting

Deleting can be done at the model level, or against the entire collection.

bc.. Car c = Car.find().first();
c.delete();

// or to delete using a query string
Car.delete("byName","Toyota");

// or just delete everything
Car.deleteAll();


h3. Relationships

This new mongo module also supports relationships between models. You can choose whether you want to define relationships which are pointing to another collection or whether you want to embed the data inside the document. The following document uses the MongoEmbedded annotation to mark it as embedded. 


bc.. @MongoEntity
public class Driver extends MongoModel {
	public String name;
}

// and declare this object a member of your model class
@MongoEntity("cars")
public class Car extends MongoModel {

	public String name;
	public String colour;
	public int topSpeed;

	@MongoEmbedded
	public Driver driver;
	
}
p. Now when we save our MongoModel to a mongo database, the driver is stored as an inner JSON document.

bc. <p> Driver Name: ${car.driver.name} </p>

Querying for inner values needs the use of a query object. If you want to query for all cars with "Andrew" as the driver.

bc. DBObject driverName = new BasicDBObject("name", "Andrew");
Car andrewCar = Car.find("byDriver", driverName).fetch();



h2. <a>Mongo specific functionality</a>

h3. Mongo Information

Models are automatically saved with a Mongo ObjectId to the specified collection. Both the ObjectId and collection name can be accessed from the model.

bc.. Car myCar = new Car("Toyota", "white", 150);
myCar.save();

ObjectId id = myCar.get_id();
String colName = myCar.getCollectionName();
h3. Mongo indexes

It is possible to create indexes against your models.

bc.. // index the name field of Car
Car.index("onName");

// create a descending index by prepending the '-' character
Car.index("on-Name");

// create a composite index by combining field names
Car.index("onNameAndColour");

// remove an index
Car.dropIndex("onName);

// remove all indexes (except the mandatory mongo index on _id)
Car.dropIndexes();

// get the names of all the existing indexes
String [] indexNames = Car.getIndexes();
p. Due to the schemaless nature of mongo, it is possible to create an index on a field which does not exist because a document containing that field may be inserted in the future. Ensure you spell your field names correctly.

h3. Authentication and Security

It is possible to run your mongo database in a secure mode, ensuring that a user must authenticate prior to performing operations on secure data. More information on setting up a secure mongo instance can be found on the Mongo website under "Security and Authentication":http://www.mongodb.org/display/DOCS/Security+and+Authentication.

Assuming you have setup your database correctly, you can leverage the authentication functionality of the mongo module as follows:

bc.. # ensure you set the necessary configuration parameters to match authentication details on your database
mongo.username=test
mongo.password=test123
p. Now you can perform the following operations in your controllers.

bc.. //add a user - with read only access
MongoDB.addUser("username","password", true);

// or write access
MongoDB.addUser("username2","password2", false);

// authenticate as a user
boolean success = MongoDB.authenticate("username","password");

// remove a user
MongoDB.removeUser("username");
p. Please note that readOnly restrictions will only apply on mongo versions 1.3.2+


h2. <a>Currently lacking features</a>

- Fixtures
- CRUD
- Using FileUpload with GridFS


h2. <a>yabe with MongoDB</a>

As a small technology demo the yabe application has been modified to work with mongodb. You can grab it at TODO

h3. Lacking features/BUGS

Several features are naturally not supported as they have not been ported to 

* Tests are not working as the Fixtures depends on Hibernate (a MongoFixtures class would be needed)
* The CRUD module is not working either (as it uses the hibernate dependent JPASupport class), you can only show your own posts and add new after logging in.

h3. Document structure

Currently there are two collections, "users" and "posts". Users contains the users who can login, posts contains all the posts including the comments. Comments are embedded, as well as tags.

h3. Importing initial data

All you need is a user, you can easily add it using the mongodb shell.

bc. alex@midnight:~$ mongo yabe
> db.users.insert({ "email" : "alr@emplify.de", "password" : "test", "fullname" : "Alexander Reelsen", "isAdmin" : true })
> db.users.find()

Optionally you can also add your own blog entries via the following statement, but they gui is really nicer for this :)

bc. alex@midnight:~$ mongo yabe
db.posts.insert( { "title" : "My first post", "postedAt" : "Sun May 23 2010 11:26:57 GMT+0200 (CEST)", "content" : "I am so tired, I should twitter about it.", "author" : { "$ref" : "users", "$id" : "4bf842a5feb39117345da5dd" }, tags : [ { name : "firstTag" } , { name : "secondTag" } ] , comments : [ { author : "Guybrush Threepwood", content : "Got malt beer?", postedAt : "Sun May 23 2010 12:26:57 GMT+0200 (CEST)" } ] } )

So this statement adds a new post containing two tags and one comment. It also has a database reference to the author, where you have to put the ObjectId of your freshly created user.

h3. Changes to the original app

Just check the source code, I commented the original lines only out, so you can compare easily.

* All jpa specififc @ManyToOne, @OneToMany, @Lob annotations have been commented out
* The routes file is changed because ids are now alphanumeric, the search for tags has been put to another URL
* The application config file contains a mongo db connection
* Getting an id of any object uses the "_id" instead of the "id" property
* Post.next() and Post.previous() depend on searching and ordering data results
* Post.findTaggedWith() uses a MongoDB "$all" matcher
* The Comment class has no dependency to the post as it is inline
* Getting the TagCloud uses a Map/Reduce job you might want to check out - in order to get a feeling for this.
* In Admin.index() controller, when using DBRefs for searching, you must call the toString() method of the ObjectId - never use the object itself as DBRef argument

Never think too complicated on how to get your data, most of the time it is pretty easy once you have freed yourself from the sql mindset.
